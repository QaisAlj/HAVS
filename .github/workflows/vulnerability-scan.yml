name: Automated Vulnerability Scan

on:
  push:[TestActions]
  pull_request:

jobs:
  scan:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for diff
    
    - name: Detect changed files
      id: changed-files
      uses: tj-actions/changed-files@v40
      with:
        files: |
          **/package.json
          **/requirements.txt
          **/pom.xml
          **/*.py
          **/*.java
          **/*.cpp
          **/*.c
    
    - name: Check for dependency files
      id: check-deps
      run: |
        if [ -n "${{ steps.changed-files.outputs.any_changed }}" ]; then
          DEPS_FOUND=false
          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            if [[ "$file" == *"package.json" ]] || [[ "$file" == *"requirements.txt" ]] || [[ "$file" == *"pom.xml" ]]; then
              DEPS_FOUND=true
              break
            fi
          done
          echo "deps_found=$DEPS_FOUND" >> $GITHUB_OUTPUT
        else
          echo "deps_found=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Check for source code files
      id: check-source
      run: |
        if [ -n "${{ steps.changed-files.outputs.any_changed }}" ]; then
          SOURCE_FOUND=false
          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            if [[ "$file" == *.py ]] || [[ "$file" == *.java ]] || [[ "$file" == *.cpp ]] || [[ "$file" == *.c ]]; then
              SOURCE_FOUND=true
              break
            fi
          done
          echo "source_found=$SOURCE_FOUND" >> $GITHUB_OUTPUT
        else
          echo "source_found=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Install Python dependencies
      if: steps.check-deps.outputs.deps_found == 'true' || steps.check-source.outputs.source_found == 'true'
      run: |
        pip install requests --quiet
    
    - name: Scan dependencies
      if: steps.check-deps.outputs.deps_found == 'true'
      id: scan-deps
      run: |
        # Collect dependency files and create JSON
        python3 << 'EOF'
        import json
        import os
        import sys
        
        # Get changed files from environment (space-separated)
        changed_files_str = os.environ.get('CHANGED_FILES', '')
        changed_files = changed_files_str.split() if changed_files_str else []
        
        files_data = []
        
        for file_path in changed_files:
            if any(file_path.endswith(ext) for ext in ['package.json', 'requirements.txt', 'pom.xml']):
                if os.path.isfile(file_path):
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                        files_data.append({
                            "path": file_path,
                            "content": content
                        })
                    except Exception as e:
                        print(f"Warning: Could not read {file_path}: {e}", file=sys.stderr)
        
        if not files_data:
            print("No dependency files found to scan", file=sys.stderr)
            sys.exit(0)
        
        # Handle PR number - only set if it's a pull request event
        pr_number = None
        pr_number_str = os.environ.get('PR_NUMBER', '')
        if pr_number_str and pr_number_str.strip() and pr_number_str.strip() != 'null':
            try:
                pr_number = int(pr_number_str)
            except ValueError:
                pr_number = None
        
        payload = {
            "files": files_data,
            "repository": os.environ.get('GITHUB_REPOSITORY'),
            "commit_sha": os.environ.get('GITHUB_SHA'),
            "pr_number": pr_number,
            "event_type": os.environ.get('GITHUB_EVENT_NAME', 'push')
        }
        
        import requests
        api_url = os.environ.get('SCANNER_API_URL')
        api_token = os.environ.get('SCANNER_API_TOKEN', '')
        
        if not api_url:
            print("Error: SCANNER_API_URL secret is not set", file=sys.stderr)
            sys.exit(1)
        
        headers = {"Content-Type": "application/json"}
        if api_token:
            headers["Authorization"] = f"Bearer {api_token}"
        
        try:
            response = requests.post(
                f"{api_url}/github/scan-dependencies",
                json=payload,
                headers=headers,
                timeout=600
            )
            response.raise_for_status()
            result = response.json()
            print(json.dumps(result, indent=2))
            # Save result to file for summary
            with open('/tmp/deps_scan_result.json', 'w') as f:
                json.dump(result, f, indent=2)
        except requests.exceptions.RequestException as e:
            print(f"Error calling scanner API: {e}", file=sys.stderr)
            if hasattr(e, 'response') and e.response is not None:
                print(f"Response: {e.response.text}", file=sys.stderr)
            sys.exit(1)
        EOF
      env:
        CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
        SCANNER_API_URL: ${{ secrets.SCANNER_API_URL }}
        SCANNER_API_TOKEN: ${{ secrets.SCANNER_API_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_SHA: ${{ github.sha }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        GITHUB_EVENT_NAME: ${{ github.event_name }}
    
    - name: Scan source code with ML
      if: steps.check-source.outputs.source_found == 'true'
      id: scan-ml
      run: |
        # Collect source code files and create JSON
        python3 << 'EOF'
        import json
        import os
        import sys
        
        # Get changed files from environment (space-separated)
        changed_files_str = os.environ.get('CHANGED_FILES', '')
        changed_files = changed_files_str.split() if changed_files_str else []
        
        files_data = []
        
        for file_path in changed_files:
            if any(file_path.endswith(ext) for ext in ['.py', '.java', '.cpp', '.c']):
                if os.path.isfile(file_path):
                    try:
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                            content = f.read()
                        
                        # Determine language
                        if file_path.endswith('.py'):
                            language = 'Python'
                        elif file_path.endswith('.java'):
                            language = 'Java'
                        elif file_path.endswith('.cpp') or file_path.endswith('.c'):
                            language = 'C/C++'
                        else:
                            language = 'Unknown'
                        
                        # Count lines
                        lines = len(content.splitlines())
                        
                        files_data.append({
                            "path": file_path,
                            "filename": os.path.basename(file_path),
                            "language": language,
                            "content": content,
                            "lines_of_code": lines
                        })
                    except Exception as e:
                        print(f"Warning: Could not read {file_path}: {e}", file=sys.stderr)
        
        if not files_data:
            print("No source code files found to scan", file=sys.stderr)
            sys.exit(0)
        
        # Handle PR number - only set if it's a pull request event
        pr_number = None
        pr_number_str = os.environ.get('PR_NUMBER', '')
        if pr_number_str and pr_number_str.strip() and pr_number_str.strip() != 'null':
            try:
                pr_number = int(pr_number_str)
            except ValueError:
                pr_number = None
        
        payload = {
            "files": files_data,
            "repository": os.environ.get('GITHUB_REPOSITORY'),
            "commit_sha": os.environ.get('GITHUB_SHA'),
            "pr_number": pr_number,
            "event_type": os.environ.get('GITHUB_EVENT_NAME', 'push')
        }
        
        import requests
        api_url = os.environ.get('SCANNER_API_URL')
        api_token = os.environ.get('SCANNER_API_TOKEN', '')
        
        if not api_url:
            print("Error: SCANNER_API_URL secret is not set", file=sys.stderr)
            sys.exit(1)
        
        headers = {"Content-Type": "application/json"}
        if api_token:
            headers["Authorization"] = f"Bearer {api_token}"
        
        try:
            response = requests.post(
                f"{api_url}/github/scan-ml",
                json=payload,
                headers=headers,
                timeout=600
            )
            response.raise_for_status()
            result = response.json()
            print(json.dumps(result, indent=2))
            # Save result to file for summary
            with open('/tmp/ml_scan_result.json', 'w') as f:
                json.dump(result, f, indent=2)
        except requests.exceptions.RequestException as e:
            print(f"Error calling ML scanner API: {e}", file=sys.stderr)
            if hasattr(e, 'response') and e.response is not None:
                print(f"Response: {e.response.text}", file=sys.stderr)
            sys.exit(1)
        EOF
      env:
        CHANGED_FILES: ${{ steps.changed-files.outputs.all_changed_files }}
        SCANNER_API_URL: ${{ secrets.SCANNER_API_URL }}
        SCANNER_API_TOKEN: ${{ secrets.SCANNER_API_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_SHA: ${{ github.sha }}
        PR_NUMBER: ${{ github.event.pull_request.number }}
        GITHUB_EVENT_NAME: ${{ github.event_name }}
    
    - name: Display Scan Summary
      if: always() && (steps.check-deps.outputs.deps_found == 'true' || steps.check-source.outputs.source_found == 'true')
      run: |
        python3 << 'EOF'
        import json
        import os
        import sys
        
        summary_lines = []
        summary_lines.append("# üîç Vulnerability Scan Summary")
        summary_lines.append("")
        summary_lines.append(f"**Repository:** {os.environ.get('GITHUB_REPOSITORY', 'N/A')}")
        summary_lines.append(f"**Branch:** {os.environ.get('GITHUB_REF_NAME', 'N/A')}")
        summary_lines.append(f"**Commit:** {os.environ.get('GITHUB_SHA', 'N/A')[:7]}")
        summary_lines.append(f"**Event:** {os.environ.get('GITHUB_EVENT_NAME', 'N/A')}")
        summary_lines.append("")
        summary_lines.append("---")
        summary_lines.append("")
        
        # Dependency Scan Results
        deps_scan_file = '/tmp/deps_scan_result.json'
        if os.path.exists(deps_scan_file):
            summary_lines.append("## üì¶ Dependency Scan Results")
            summary_lines.append("")
            try:
                with open(deps_scan_file, 'r') as f:
                    deps_result = json.load(f)
                
                if isinstance(deps_result, dict):
                    # Extract key information
                    vulnerabilities = deps_result.get('vulnerabilities', [])
                    total_vulns = len(vulnerabilities) if isinstance(vulnerabilities, list) else 0
                    
                    summary_lines.append(f"**Status:** ‚úÖ Scan Completed")
                    summary_lines.append(f"**Total Vulnerabilities Found:** {total_vulns}")
                    summary_lines.append("")
                    
                    if total_vulns > 0:
                        summary_lines.append("### Vulnerabilities:")
                        summary_lines.append("")
                        for i, vuln in enumerate(vulnerabilities[:10], 1):  # Show first 10
                            if isinstance(vuln, dict):
                                name = vuln.get('name', vuln.get('package', 'Unknown'))
                                severity = vuln.get('severity', vuln.get('level', 'Unknown'))
                                summary_lines.append(f"{i}. **{name}** - Severity: `{severity}`")
                        if total_vulns > 10:
                            summary_lines.append(f"\n*... and {total_vulns - 10} more vulnerabilities*")
                    else:
                        summary_lines.append("‚úÖ No vulnerabilities detected in dependencies!")
                    
                    # Show full JSON in collapsible section
                    summary_lines.append("")
                    summary_lines.append("<details>")
                    summary_lines.append("<summary>View Full Dependency Scan Results</summary>")
                    summary_lines.append("")
                    summary_lines.append("```json")
                    summary_lines.append(json.dumps(deps_result, indent=2))
                    summary_lines.append("```")
                    summary_lines.append("</details>")
                else:
                    summary_lines.append(f"**Status:** ‚úÖ Scan Completed")
                    summary_lines.append("")
                    summary_lines.append("```json")
                    summary_lines.append(json.dumps(deps_result, indent=2))
                    summary_lines.append("```")
            except Exception as e:
                summary_lines.append(f"**Status:** ‚ö†Ô∏è Error reading results")
                summary_lines.append(f"**Error:** {str(e)}")
        else:
            summary_lines.append("## üì¶ Dependency Scan Results")
            summary_lines.append("")
            summary_lines.append("‚ÑπÔ∏è No dependency files were scanned")
        
        summary_lines.append("")
        summary_lines.append("---")
        summary_lines.append("")
        
        # ML Source Code Scan Results
        ml_scan_file = '/tmp/ml_scan_result.json'
        if os.path.exists(ml_scan_file):
            summary_lines.append("## ü§ñ ML Source Code Scan Results")
            summary_lines.append("")
            try:
                with open(ml_scan_file, 'r') as f:
                    ml_result = json.load(f)
                
                if isinstance(ml_result, dict):
                    # Extract key information
                    vulnerabilities = ml_result.get('vulnerabilities', [])
                    issues = ml_result.get('issues', [])
                    findings = vulnerabilities if vulnerabilities else issues
                    total_findings = len(findings) if isinstance(findings, list) else 0
                    
                    summary_lines.append(f"**Status:** ‚úÖ Scan Completed")
                    summary_lines.append(f"**Total Issues Found:** {total_findings}")
                    summary_lines.append("")
                    
                    if total_findings > 0:
                        summary_lines.append("### Security Issues:")
                        summary_lines.append("")
                        for i, issue in enumerate(findings[:10], 1):  # Show first 10
                            if isinstance(issue, dict):
                                file_path = issue.get('file', issue.get('path', 'Unknown'))
                                issue_type = issue.get('type', issue.get('vulnerability_type', 'Unknown'))
                                severity = issue.get('severity', issue.get('level', 'Unknown'))
                                line = issue.get('line', issue.get('line_number', 'N/A'))
                                summary_lines.append(f"{i}. **{file_path}** (Line {line})")
                                summary_lines.append(f"   - Type: `{issue_type}` | Severity: `{severity}`")
                        if total_findings > 10:
                            summary_lines.append(f"\n*... and {total_findings - 10} more issues*")
                    else:
                        summary_lines.append("‚úÖ No security issues detected in source code!")
                    
                    # Show full JSON in collapsible section
                    summary_lines.append("")
                    summary_lines.append("<details>")
                    summary_lines.append("<summary>View Full ML Scan Results</summary>")
                    summary_lines.append("")
                    summary_lines.append("```json")
                    summary_lines.append(json.dumps(ml_result, indent=2))
                    summary_lines.append("```")
                    summary_lines.append("</details>")
                else:
                    summary_lines.append(f"**Status:** ‚úÖ Scan Completed")
                    summary_lines.append("")
                    summary_lines.append("```json")
                    summary_lines.append(json.dumps(ml_result, indent=2))
                    summary_lines.append("```")
            except Exception as e:
                summary_lines.append(f"**Status:** ‚ö†Ô∏è Error reading results")
                summary_lines.append(f"**Error:** {str(e)}")
        else:
            summary_lines.append("## ü§ñ ML Source Code Scan Results")
            summary_lines.append("")
            summary_lines.append("‚ÑπÔ∏è No source code files were scanned")
        
        summary_lines.append("")
        summary_lines.append("---")
        summary_lines.append("")
        summary_lines.append("üìù *Results are also posted to GitHub via API*")
        
        # Write summary to both stdout and file
        summary_text = "\n".join(summary_lines)
        print(summary_text)
        
        # Write to GitHub Actions summary
        summary_file = os.environ.get('GITHUB_STEP_SUMMARY', '/dev/null')
        try:
            with open(summary_file, 'w') as f:
                f.write(summary_text)
        except Exception:
            pass  # Ignore if file doesn't exist
        
        EOF
      env:
        GITHUB_REPOSITORY: ${{ github.repository }}
        GITHUB_REF_NAME: ${{ github.ref_name }}
        GITHUB_SHA: ${{ github.sha }}
        GITHUB_EVENT_NAME: ${{ github.event_name }}
    
    - name: Post results to GitHub
      if: always() && (steps.check-deps.outputs.deps_found == 'true' || steps.check-source.outputs.source_found == 'true')
      run: |
        # Results are automatically posted by backend via GitHub API
        echo "Results posted to GitHub"

